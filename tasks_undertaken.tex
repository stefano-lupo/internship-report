\chapter{Tasks Undertaken}
Throughout the course of the internship, a variety of tasks were undertaken and completed.  
For the sake of brevity a small subset of the most interesting of these tasks are outlined below. 

\section{Rebuilt DNS Management System}
\textbf{MAKE SURE THIS MAKES SENSE WRT DNS, DISCUSS EACH OF THE DNS RECORDS}\hfill\break
DNS plays an important part in sending emails. As discussed in \refsec{sec:DNS}, there a several DNS records that must be maintained for a server to send email. As HubSpot aims to offer as seemless an experience as possible to it's customers, it attempts to take care of as much of the DNS settings as possible on behalf of the customer. Ultimately however, if a customer want's HubSpot to send their marketing emails through an SMTP domain of \java{emails.company.com}, these DNS records must be obtainable at that domain as discussed in \refsec{sec:DNS}. 

As things change at HubSpot, it is quite likely that these DNS records would need to change over time. For example, if the customer should add another dedicated IP address to their account, this would have to be added to their SPF record. At first glance this would require HubSpot's customers to be frequently changing their DNS records, something most customer's would not be overly comfortable with. The solution to this problem (as with so many problems in computer science) is indirection. 

The Domain Name System supports the concept of including other DNS records, even from entirely different domains. This is exactly the behaviour that lets HubSpot manage their customers' DNS on their behalf. For example, instead of \java{emails.company.com} having the SPF record which contains their allowed sending IPs and having to change it when things change, they can simply setup this record as a pointer to another DNS record, a record on HubSpot's domain. Clients who require the SPF record for for \java{emails.company.com} will be informed to use the record contained on HubSpot's domain instead. An example of this is shown in \reffig{fig:dnsIncludes}, where 99 is the customer's HubSpot identification number. 

Thus once the customer only ever needs to set up the DNS pointers to HubSpot's domain once. Once that is done, HubSpot can control the actual values of those DNS records on behalf of the customer. 

\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{renders/DnsIncludes.png}
      \caption{DNS Includes for \textit{emails.company.com}, HubSpot Customer 99.}
      \label{fig:dnsIncludes}
\end{figure}


\section{Auto DNS for dedicated IPs} \label{sec:autoDns}

\section{EmailMtaSending Kafka}

\section{CIDR Minimization Algorithm}
\textbf{MAKE SURE THIS MAKES SENSE WRT DNS, DISCUSS STRUCTURE OF SPF}\hfill\break
As discussed in \refsec{sec:DNS}, SPF records are a vital part of authorization when it comes to sending emails. SPF records are typically used to specify a set of IP addresses that a particular domain may send emails from. An important aspect of SPF records (or more specifically, the underlying TXT record) is that the length of the entire record value (which is a simple string) should be at most 255 characters as per RFC 7208 \cite{spfRFC}. Given the fact that a particular HubSpot customer may potentially send email over any one of tens of HubSpot owned IPs, this can cause problems. As discussed in \refsec{sec:autoDns}, one of the upgrades customers can avail of is purchasing dedicated IP addresses, which will be used for their email traffic and theirs only. HubSpot owns a large number of IP addresses in order to facilitate this. One of the decisions that needed to be made by support staff working with customers was which IP address(es) to assign to customers. Some customers have existing IP addresses and IPs should be selected in order to minimize the length of the resulting SPF record that the customer will have. SPF records support CIDR notation (see \refsec{sec:CIDR}) of IP addresses, meaning smart IP selection can save valuable characters in a customer's SPF record. As HubSpot is moving towards automating the setting up of customer accounts with dedicated IP addresses (see \refsec{sec:autoDns}), this IP address selection needed to be automated, while still minimizing the resulting SPF records.

\subsection{CIDR Notation} \label{sec:CIDR}
CIDR (Classless Inter-Domain Routing) notation is a compact way to represent an IP address along with its associated subnet mask and network prefix \cite{cidr}. With regards to SPF records, it is useful as it can be used to compactly represent a set of IP addresses. This set consists of the IP addresses of all of the hosts on the sub-network (subnet) specified by the network prefix. This section will primarily discuss CIDR notation for version four (IPv4) IP addresses, though all of the same logic holds for version six (IPv6) IP addresses. 

Typically IP addresses are represented as quartet of period separated integers ranging from 0 - 255, for example, $192.168.1.1$. However, this representation is simply employed in order to make reading IP addresses easier for humans. In actuality, version four IP addresses are more simply represented as 32 bit integers. Each of the numbers in the quartet can take on one of 256 values. Thus

\begin{equation}
\begin{split}
\log_2 256 = 8\,bits\,per\,element\,in\,quartet \\
8\,bits\,per\,element \times 4\,elements\,in\,quartet = 32\, bits
\end{split}
\end{equation}



$192.168.1.1$ could be represented as a 32 bit integer by using $192$ as the most upper (most significant) 8 bits, $168$ as the next 8 bits and so on. CIDR notation contains the IP address in question, followed by a slash and a number, for example $192.168.1.2/31$. CIDR notation partitions the 32 bit representation of the IP address into two pieces - the upper bits make up the network prefix and the remaining bits are used to specify the specific host on that network. The number following the slash denotes the number of bits to use for the network prefix. Thus $192.168.1.3/31$ specifies that 31 out of the 32 bits should be used for the network prefix and all other bits should be zeroed in order to obtain the network address. This implies that the network address is $192.168.1.2$. This is because the least significant byte of this IP address is 3, or $(0000 0011)_2$ in binary, and the last bit is to be zeroed meaning the last byte of the network address becomes $(0000 0010)_2$, which is 2 in base-10. 

CIDR notation can thus be used to represent a set of IP addresses, provided they are contiguous, the set has a cardinality that is an integral power of 2 and the first IP address in the set lies on a CIDR boundary. The set of IPs $\{192.168.1.0, 192.168.1.1\}$ can be represented using CIDR notation as $192.168.1.0/31$. The logic here is that the address of the subnet containing the hosts of interest is provided and the implied set of IPs is the set of all IP addresses of the hosts on that subnet.  Thus if a customer owns these two IP addresses, their SPF record can simply contain the CIDR notation value of the subnet which contains the two IP addresses, reducing the number of characters required by almost half. This is due to the fact that $/31$ implies that there is one bit (the last bit) which identifies the host on the subnetwork defined by $192.168.1.0$. This bit can either be a zero or a one, yielding the two possible IP addresses that were started with - $192.168.1.0$ or $192.168.1.1$.

\subsection{A Simplified Version of the Algorithm}
The main objective of the algorithm is sumarised as follows (Note if the CIDR postfix is ommited, $/32$ is impied): \hfill\break\break
Given a set of existing IP addresses $S_e$ (the \textit{existing} set) and a set of available IP addresses $S_a$ (the \textit{available} set), choose a set of $n$ IP addresses $S_c$ (the \textit{chosen} set) from $S_a$ such that the resulting number of characters of the CIDR representation of the final set of IP addresses $S_f$ is minimized, where 

\begin{equation}
S_f = S_e \cup S_c
\end{equation}

An example scenario in which the algorithm could be used is given in \refeq{eq:ipAlgExample}
\begin{equation}\label{eq:ipAlgExample}
\begin{split}
 &   S_e = \{1.1.1.1, 1.1.1.2\} \\
 &   S_a = \{1.1.1.0, 1.1.1.3, 1.1.1.4, 1.1.1.5\} \\
 &   n = 2 \\
\end{split}
\end{equation}

In this scenario, the algorithm should result in $S_c = \{1.1.1.0, 1.1.1.3\}$, resulting in $S_f = \{1.1.1.0, 1.1.1.1, 1.1.1.2, 1.1.1.3\}$ which is represented in CIDR notation as $S_f = \{1.1.1.0/31\}$. Critically, although the set of IPs $\{1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.1.4\}$ are contiguous, the CIDR representation of these IPs is $\{1.1.1.1, 1.1.1.2/30, 1.1.1.4\}$ \textbf{not} $\{1.1.1.1/30\}$.

Although the algorithm could likely be brute forced by generating every possible set of IP addresses and choosing the one with the fewest characters in the CIDR representation, this algorithm would run in exponential time making it less than ideal.

In order to attempt to gain some deeper insight into the problem, a common mathematical approach was used in which a simpler version of the problem was considered - the case where there is no existing IPs ($S_e = \{\}$). For convenience, a new variable $t$ is also introduced to represent the total number of IPs in the final set (the cardinality of $S_f$). Thus:

\begin{equation}
t = |S_f| = |S_e| + n
\end{equation}

The first step of the algorithm requires determining the largest possible CIDR block that could be obtained for a given $t$. The number of IPs in a CIDR block is related to the number of bits available for representing the hosts on the subnetwork. Thus, the number of IPs in a CIDR block must always be an integral power of 2. This is shown in \reftbl{tbl:cidrBlockSize}. 

The calculation for the number of host bits $n\sub{hb}$ is shown in \refeq{eq:numHostBits} where $n\sub{ab}$ represents the number of address bits (the value after the $\setminus$)

\begin{equation}\label{eq:numHostBits}
n\sub{hb} = 32 - n\sub{ab} 
\end{equation} 

The calculation for the number of hosts on the subnetwork ($n\sub{hosts}$) is given by the number of digits that the number of host bits $n\sub{hb}$ can represent and is shown in \refeq{eq:numHosts}.

\begin{equation}\label{eq:numHosts}
n\sub{hosts} = 2 ^ {n_{hb}}
\end{equation}

\begin{table}[H]
\caption{The Size of CIDR blocks as a function of $n_{hb}$}
\label{tbl:cidrBlockSize}
\centering
\begin{tabular}{l l l}
\toprule
\textbf{Example Address} & \textbf{Number of Host Bits $n\sub{hb}$} &\textbf{Number of IPs in Block $n\sub{hosts}$} \\
\midrule
1.1.1.0/32 & 0 & 1\\
1.1.1.0/31 & 1 & 2\\
1.1.1.0/30 & 2 & 4\\
1.1.1.0/29 & 3 & 8\\
... & ... & ...\\
\bottomrule\\
\end{tabular}
\end{table}

Thus, the largest possible block of CIDR IPs for a given $t$ can be obtained by finding the highest integral power of two that is lower than $t$. For example, if $t = 10$, then 8 would be the largest possible CIDR block as $2^3 = 8$ but $2^4 = 16$.

An importance concept of the algorithm is assigning each IP address to a certain bucket. This assignment process needs to know what bucket size to use. Critically, the bucket sized used will be an integral power of 2 aligning with the above table. The IPs will be placed into the bucket that represents the subnet that they would be contained within for a given number of host bits. Logically, the presence of a filled bucket indicates that a CIDR block can be formed from the set of IPs contained in that bucket. An example is shown in \reffig{fig:exampleIpsByBucket4}. In this case, bucket $1.1.1.0$ is full and the bucket size is 4, meaning the IPs inside it can be used to create a CIDR block of size 4 $1.1.1.0\setminus30$.

\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{renders/IpsByBucketSize4.png}
      \caption{Assigning IPs to Buckets with a Bucket Size of 4}
      \label{fig:exampleIpsByBucket4}
\end{figure}

As discussed, the bucket size will be an integral power of 2, but an important question is which integral power of 2. The algorithm starts by assigning the IPs to their buckets using a bucket size equal to the largest possible CIDR block that can be obtained for the given $t$, as discussed previously.

At this point, the algorithm begins to take shape. Consider the situation represented in \reffig{fig:exampleIpsByBucket4} along with a value of $t = 4$. The inital bucket size will be 4 and the presence of a filled bucket ($1.1.1.0/30$) indicates that a CIDR block of the bucket size can be created. Since the bucket size is equal to the desired number of IPs, the optimal choice is the $1.1.1.0/30$ block.

Next consider the situation represented in \reffig{fig:exampleIpsByBucket4} along with a value of $t = 6$. The initial bucket size will still be 4 (as this is the largest integral power of 2 smaller than $t$). Thus, the algorithm will again detect that the $1.1.1.0/30$ bucket is full and select this block of four IPs. However the algorithm must return a total of $t = 6$ IPs and therefore must select a further 2 IPs. The algorithm accomplishes this by making a recusrive call. By removing all of the (so far) selected IPs from the set of available IPs (forming the $S_a'$) and setting the new value of $t$ to be the remaning number of IPs required ($t'$), a recursive call will simply find the best set of IPs from what is left. This is shown in \reffig{fig:exampleIpsByBucket2} in which the recusrive call would return $1.1.1.4/31$ as this bucket is full. 

\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{renders/IpsByBucketSize2.png}
      \caption{Assigning Remaining IPs to Buckets with a Bucket Size of 2}
      \label{fig:exampleIpsByBucket2}
\end{figure}

In the case of $t = 7$, the algorithm would proceed as before, with one extra recusrive call with $t = 1$. Assuming there were sufficient IPs available (the number of IPs in the diagrams were limited for brevity), the algorithm would have selected the same 6 IPs as before and the final call would be the trivial case of $t = 1$ in which a random IP can be selected. At each stage, the set of IPs returned from the recusrive calls can then be unioned with the current call's chosen IPs, and the unioned set returned. 

The final possibility to consider is what should be done when no buckets are filled. In this case, the algorithm should not select any IPs at this bucket size. Instead, it should reduce the bucket size to the next highest integral power of 2 and recurse, setting $t$ equal to this reduced bucket size. However, there is another important step, the need for which is best illustrated with an example. A diagram of this situation is shown in \reffig{fig:ipAlgTrickyCodePath}

If the initial value for $t$ is 6, the initial bucket size will be 4. If no buckets of size 4 are filled, the algorithm will then recurse. Let the total number of IPs requied that is used for this recusrive call be denoted as $t_1'$. Thus, for the recursive call, $t_1' = 2$ (the next largest integral power of 2 as discussed previously) and the set of available IPs is unchanged $S_{a_1} = S_a$. Let the set of chosen IPs returned from this first recursive call be denoted as $S_{c_1}$.

The initial call required 6 IPs to be returned, however this first recursive call will always return 2 IPs that should be used. Thus a second recursive call is required. Let the total number of IPs required that is used for this second recursive call be denoted as $t_2'$. $t_2'$ is calculated using the formula given in \refeq{eq:secondRecurseT2}. This is simply the remaining number of IPs that need to be chosen after the first recursive call. 

\begin{equation}\label{eq:secondRecurseT2}
t_2' = t - t_1'
\end{equation}

Finally, the set of available IPs that is used for the second recursive call ($S_{a_2}$) is given by \refeq{eq:availableIpsSecondRecurse}. This is the initial set of all available IPs, with the IPs chosen from the first recursive call ommited.

\begin{equation}\label{eq:availableIpsSecondRecurse}
S_{a_2} = S_a - S_{c_1}
\end{equation}

\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{renders/IpAlgTrickyCodePath.png}
      \caption{Code Path when Algorithm Does Not Find Full Bucket}
      \label{fig:ipAlgTrickyCodePath}
\end{figure}

The steps of the algorithm (for the simplified case of having no existing IPs) are shown below:
\begin{itemize}
\item{Set bucket size to be largest integral power of 2 that is less than $t$}
\item{Assign all available IPs into buckets using the calculated bucket size}
\item{If a bucket is full}
  \begin{itemize}
  \item{Add all of the IPs in the bucket to the set of chosen IPs ($S_c$)}
  \item{Remove all of the IPs in the bucket from the set of available IPs (forms $S_a'$)}
  \item{Calculate $t'$ as $t - bucketSize$}
  \item{Recurse using $S_a'$ and $t'$ (if neccessary)}
  \end{itemize}
\item{Otherwise}
  \begin{itemize}
  \item{Recurse using next biggest integral power of 2 and the initial set of available IPs}
  \item{Recurse using the remaining number of IPs required and the set of available IPs, excluding those returned from the previous recursive call}
  \item{Return the union of the results of the two recursive calls.}
  \end{itemize}
\end{itemize}

\subsection{Extending the Algorithm to Support Existing IPs}
Now that a solution to the simplified problem where $S_e = \{\}$ has been formed, the more complex initial problem could now be tackled. However upon closer inspection, there is only one extra point to consider when the set of existing IPs is non empty: \textbf{the final set must be a superset of the set of existing IPs}. 

The algorithm now requires the following arguments:

\begin{itemize}
\item{A list of available IPs - $S_a$}
\item{A list of existing IPs - $S_e$}
\item{The total number of IPs desired - $t$}
\item{The bucket size to use - $b$}
\end{itemize}

The main changes to the algorithm are the following:

\begin{itemize}
  \item{Assign the existing IPs ($S_e$) to buckets using the provided bucket size}
  \item{(separetly) Assign the available IPs ($S_a$) to buckets using the provided bucket size}
  \item{For each of the \textit{existing} IP buckets $S_{e_i}$}
      \begin{itemize}
      \item{Calculate $b^*_i$, the number of IPs required to fill the bucket (\refeq{eq:ipsToFillBucket})}
      \item{If the number of IPs in the corresponding \textit{available} IP bucket ($S_{a_i}$) equals $b^*_i$, the union of the two buckets creates a CIDR block and should be added to the currently chosen set of IPs ($S_c$), as long as it doesn't $|S_c|$ to become larger than the total number of desired IPs, $t$}
      \item{If the size of $S_c$ is now equal to $t$ (the total number of IPs required), $S_c$ can be returned.}
      \end{itemize}
\end{itemize}


\begin{equation}\label{eq:ipsToFillBucket}
b^*_i= b-|S_{e_i}|
\end{equation}


This shows that the only logical change is that the number of IPs required to fill the existing IP buckets should be examined, rather than searching for full buckets from the available pool. 

As with the simplified case, this method may require some recursion after the above steps. The recursive call in this case is actually simpler, but depends on the current state of the algorithm. As previously mentioned, all of the IPs in the existing set should be contained in the final set. If the algorithm reaches a state where all of the existing IPs have been used, but there is still a number of IPs to be selected, the algorithm can simply fallback to the previous case where $S_e = \{\}$. Otherwise, the algorithm recurses using the remaining available IPs, the remaining \textit{required} IPs (this is the set of existing IPs that have not yet been used), the remaining number of IPs required to be chosen and the next bucket size to use which is one less than the current bucket size.

Consider the following example as shown in \reffig{fig:ipsByBucketExisting4}.
\begin{itemize}
\item{$S_e = \{1.1.1.0, 2.2.2.0\}$}
\item{$S_a = \{1.1.1.1, 1.1.1.2, 1.1.1.3, 2.2.2.1, 2.2.2.2\}$}
\item{$t = 7$}
\end{itemize}

As $t = 7$, the initial bucket size $b$ would be 4 and the IPs would be assigned to buckets as shown in \reffig{fig:ipsByBucketExisting4}

The algorithm would then proceed in the following manner:
\begin{itemize}
\item{Examine each existing ($S_{e_i}$) and available ($S_{a_i}$) IP buckets in pairs}
\begin{itemize}
\item{Calculate $b_i^*$ for $1.1.1.0/30$ as per \refeq{eq:ipsToFillBucket}, yielding 3}
\item{Add $1.1.1.0/30$ to $S_c$ as $b^*_i = |S_{a_i}| = 3$}
\end{itemize}
\begin{itemize}
\item{Calculate $b_i^*$ for $2.2.2.0/30$ as per \refeq{eq:ipsToFillBucket}, also yielding 3}
\item{Skip $2.2.2.0/30$ as $b^*_i > |S_{a_i}|$ ($3 > 2$)}    
\end{itemize}
\end{itemize}

\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{renders/IpsByBucketSize4Existing.png}
      \caption{Available and Existing IPs Assigned to Buckets of size 4}
      \label{fig:ipsByBucketExisting4}
\end{figure}

Since the total number of IPs required was $t = 7$ and only 4 IPs have been selected, a recusrive call is required. As there are still some existing IPs that have not been included, a recursive call is made with the following parameters:
\begin{itemize}
\item{$S'_e = \{2.2.2.0\}$}
\item{$S'_a = \{2.2.2.1, 2.2.2.2\}$}
\item{$t' = 3$}
\end{itemize}

As $t'=3$, the next bucket size will be $b' = 2$ (the highest integral power of 2 smaller than $t'$). Thus, the IPs will be assigned to buckets of size 2, as shown in \reffig{fig:ipsByBucketExisting2}.

The algorithm will then proceed as follows:
\begin{itemize}
\item{Examine the remaining existing ($S'_{e_i}$) and available ($S'_{a_i}$) IP buckets in pairs}
\begin{itemize}
\item{Calculate $b*'_i$ for $2.2.2.0/31$ as per \refeq{eq:ipsToFillBucket}, yielding 1}
\item{Add $2.2.2.0/31$ to $S_c$ as $b*'_i = |S'_{a_i}| = 1$} 
\end{itemize}
\end{itemize}

\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{renders/IpsByBucketSize2Existing.png}
      \caption{Remaining Available and Existing IPs Assigned to Buckets of size 2}
      \label{fig:ipsByBucketExisting2}
\end{figure}

Finally since a total of 7 IPs were required and 6 were selected, a final recursive call is required. However all of the existing IPs are now included in $S_c$, meaning the existing IPs argument for the next recusrive call will empty. This means the algorithm falls back to the simple case as described earlier and will choose a random final IP ($2.2.2.2$ in this case). 

There are two enhancements that can be made to the algorithm at this point. The first is a better method for choosing a single IP from the available IP pool. Ideally, the algorithm should choose an \textit{awkward} IP that does not have any free neighbouring IPs. Otherwise, the algorithm may break up valuable CIDR blocks by choosing randomly. This is described in \refapp{appendix:smartSingleIP}. 

The other enhancement applies only to the case where the existing set of IPs is non empty. The previously described method of choosing the highest integral power of 2 that is less than $t$ for the initial bucket size only makes sense for the case $S_e = \{\}$. For example, given $S_e = \{1.1.1.0, 2.2.2.0\}$ and $t = 4$, the algorithm must choose two IPs. The described method would suggest starting with a bucket size of $b=4$. However it would be impossible to generate a CIDR block of size 4 given the existing IPs and a choice of only two IPs. An extension to the algorithm to handle choosing the optimum starting bucket size is outlined in \refapp{appendix:smartInitBucket}. 

Finally, the source code for the algorithm is given in \refapp{appendix:algSourceCode}

\subsection{Unit Testing the Algorithm}
The final step in the development was to write exstensive unit tests to ensure the algorithm operates as expected. Unit testing is an critical part of the software development process at HubSpot and engineers are always encouraged to write code which is as unit testable as possible. As the code is essentially a number of static utility functions, unit testing is quite simple and does not require mocking any complex objects.  

The initial task was to come up with an example state to test the algorithm with. The example state contains the set of available IP addresses $S_a$ and the set of existing IP addresses $S_e$. These should be chosen in such a way that all code paths of the algorithm are seen at some point or another when running the tests. This requires some consideration as for what is contained in $S_a$ and $S_e$, as well as the total number of IPs required, $t$, for each of the test cases.

As a starting point, the following sets of IPs were chosen for the default state (this can be changed on a per test basis of course):

\begin{equation}\label{eq:initialState}
\begin{gathered}
S_a = \{1.1.1.2, 1.1.1.3, 1.1.1.4, 1.1.1.5, 1.1.1.6, 1.1.1.7, 1.1.1.8, 1.1.1.9\} \\
S_e = \{1.1.1.0, 1.1.1.1\}
\end{gathered}
\end{equation}

Initially however, tests were written for the simplified case where $S_e = \{\}$. The following tests were then implemented:

\begin{itemize}
\item{The algorithm should choose contiguous blocks when avaialble}
      \begin{itemize}
      \item{This was tested by simply requesting that 4 IPs be selected from $S_a$ and ensuring that the resulting set was $\{1.1.1.4/30\}$.}
      \end{itemize}
\item{The algorithm should find contiguous blocks of IPs when a single IP will be left over}
      \begin{itemize}
      \item{This was tested by requesting that 5 IPs be selected from $S_a$}
      \item{The resulting set should contain the block of 4 IP addresses ($1.1.1.4/30$) and a single other IP}
      \item{This test was added to ensure that the algorithm still selected a block of four instead of trying to find several blocks of 2}
      \end{itemize}
\item{The algorithm should find contiguous IPs recursively}
      \begin{itemize}
      \item{This was tested by requesting that 6 IPs be selected from $S_a$}
      \item{The resulting set should contain the block of 4 IP addresses ($1.1.1.4/30$) as before, but should critically select the $1.1.1.2/31$ block for the remaining 2 IP addresses}
      \item{This test was sufficient to assume the algorithm would recursively select CIDR blocks at lower block sizes when available}
      \end{itemize}
\item{The algorithm should always return the correct number of IP addresses}
      \begin{itemize}
      \item{This test was implemented by repeatedly invoking the algorithm with $t$ running from $1$ to $|S_a|$}
      \end{itemize}
\end{itemize}

These tests were sufficient for the simple case where $S_e = \{\}$ and the algorithm was then tested using the more complex case. The following tests were implemented in order to ensure correctness of the algorithm:

\begin{itemize}
\item{The algorithm should find contiguous blocks when provided with existing IP addresses}
      \begin{itemize}
      \item{This was tested by requesting a total of 4 IPs, given the default state as described in \refeq{eq:initialState}}
      \item{The algorithm should then select $\{1.1.1.2/31\}$} so that when unioned with $S_e = \{1.1.1.0/31\}$, the CIDR block $\{1.1.1.0/30\}$  is formed 
      \end{itemize}
\item{The algorithm should always return the correct number of IPs and contain all of the existing IPs}
      \begin{itemize}
      \item{This test was an important test as the algorithm would be useless if it minimized CIDR blocks but didn't guarantee that all of the existing IPs would be present in the resulting set}
      \item{This test was implemented by allowing a variable $i$ to take on values from $1$ to $|S_a|$ and by setting $t = S_e + i$.}
      \item{This essentially repeatedly runs the algorithm, requesting each possible value from the minimum number of new IPs (1), to the maximum number of new IPs (the number of available IPs)}
      \item{At each iteration, the returned set was checked to ensure the correct number of IPs was returned and that all of the existing IPs were contained in that set.}
      \end{itemize}
\item{The algorithm was also tested to ensure it would look for contiguous blocks both above and below (in the IP address space) the existing IPs provided in order to try and find CIDR blocks}
      \begin{itemize}
      \item{This was tested by requesting a total of 2 IPs and setting $S_e = \{1.1.1.3\}$}
      \item{This tested that the algorithm would find CIDR blocks below the existing IPs provided}
      \item{The returned set should be $1.1.1.2/31$, indicating the algorithm correctly searches below the provided existing IPs}
      \item{A similar test was written where $S_e = {1.1.1.2}$ and the algorithm correctly returned $1.1.1.2/31$ indicating that it also looks above the provided existing IP addresses for CIDR blocks}
      \end{itemize}
\item{The algorithm should find CIDR blocks with existing IP addresses that cause a single IP to be left over}
      \begin{itemize}
      \item{This was tested by requesting a total of 9 IPs using the default state as shown in \refeq{eq:initialState}}
      \item{The resulting set should contain the CIDR block of 8 IPs ($1.1.1.0/29$) and the remaining extra IP ($1.1.1.9$)}
      \end{itemize}
\item{The algorithm should return already grouped existing IPs}
      \begin{itemize}
      \item{It is essentially impossible to break up a CIDR block contained inside the set of existing IP addresses, but this test was added to ensure the algorithm correctly identified existing CIDR blocks appropriately.}
      \item{A set of existing IPs $S_e = \{2.2.2.0/31\}$ was used along with an the available set of IPs listed in \refeq{eq:initialState} and a total of 4 IPs were requested.}
      \item{The algorithm correctly returned the existing CIDR block as well as another CIDR block of size 2, yielding $\{1.1.1.2/31, 2.2.2.0/31\}$}
      \end{itemize}
\item{The algorithm should handle existing IPs which don't contribute to any CIDR blocks and should fill the remaining number of IPs required with the best CIDR block from the avaialble set of IPs}
      \begin{itemize}
      \item{This was tested by setting $S_e = \{2.2.2.0, 3.3.3.0, 4.4.4.0\}$}, using the set of available IPs shown in \refeq{eq:initialState} and requesting 5 IPs.
      \item{The algorithm should then return the three existing IPs along with a CIDR block of size 2 from the set of available IPs}
      \end{itemize}
\end{itemize}

These tests provided a sufficient amount of coverage to provide confidence in the algorithm and its implementation. Several other tests were implemented which were less specific to the algorithm (such as ensuring user input was validated). The algorithm has been running in a production environment for over 3 months and has helped automate an important step that was previously being performed manually by a support team at HubSpot.   