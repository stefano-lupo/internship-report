\begin{appendices}

\chapter{Source Code for DNS Management System}
\label{appendix:dnsManagement}
\lstinputlisting[
  caption={The DnsRecordBuilder interface},
  label={lst:dnsRecordBuilder},
  style=javaStyle
  ]{code/tasks_undertaken/dns_management/DnsRecordBuilder.java}

\lstinputlisting[
  caption={Apply \java{DnsRecordBuilder}s and find records that need updating.},
  label={lst:recordBuilderApplier},
  style=javaStyle
  ]{code/tasks_undertaken/dns_management/DnsRecordBuilderApplier.java}

\lstinputlisting[
  caption={A simplified DNS sync job implementation},
  label={lst:dnsSyncJob},
  style=javaStyle
  ]{code/tasks_undertaken/dns_management/DnsSyncJob.java}

\chapter{CIDR Minimization Algorithm - Choosing a single IP}
\label{appendix:smartSingleIP}
When selecting a single IP from the available pool, ideally, the algorithm should choose an \textit{awkward} IP that does not have any free neighboring IPs. Otherwise, the algorithm may break up valuable CIDR blocks by choosing randomly. 

This enhancement to the algorithm was added by examining the set of available IPs and recursively looking at larger and larger bucket sizes, to find the largest bucket that contains only a single available IP. This IP has no chance of forming a CIDR block at the largest bucket size (given the available set of IPs) and should thus be used when searching for a single IP. 

This allows IPs that \textit{may} form CIDR blocks to be kept available for cases when more than 1 IP is requested. 


\chapter{CIDR Minimization Algorithm - Initial Bucket Size}
\label{appendix:smartInitBucket}
The previously described method for choosing the initial bucket size was choosing the highest integral power of 2 that is less than or equal to $t$. This method only makes sense for the case where $S_e = \{\}$. 

For example, given $S_e = \{1.1.1.0, 2.2.2.0\}$ and $t = 4$ the algorithm must choose two IPs ($n = 2$). The described method would suggest starting with a bucket size of $b=4$. However it would be impossible to generate a CIDR block of size 4 given the existing IPs and a choice of only two IPs, \textbf{regardless of the available IPs}. 

This extension is handled by a separate function which is called prior to starting the algorithm, to determine the appropriate starting bucket size. This function only requires the total number of IPs desired ($t$) and the existing set of IPs ($S_e$) as parameters. 

The function starts by assigning IPs to buckets using the largest integral power of 2 less than or equal to $t$ rule. It then calculates $n$ (the number of IPs that need to be chosen from the available pool) and checks if any of the existing buckets require \textbf{$n$ or less} IPs to be filled. As only $n$ IPs can be selected, if no buckets can be \textit{filled} by selecting $n$ IPs, there is no possibility of creating CIDR blocks at this bucket size. This is done without considering the available IPs. Thus even if a bucket \textit{could} be filled by choosing $n$ IPs, it may not be. If no buckets can be filled choosing $n$ IPs, the function recurses, checking the next largest bucket size. Otherwise, the function returns the current bucket size.



\end{appendices}